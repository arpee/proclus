<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Saito Network: Development Roadmap</title>

  <script type="text/javascript" src="/jquery/jquery-3.2.1.min.js"></script>
  <link rel="stylesheet" href="/jquery/jquery-ui.min.css" type="text/css" media="screen" />
  <script type="text/javascript" src="/jquery/jquery-ui.min.js"></script>

  <link rel="stylesheet" type="text/css" href="style.css" />

</head>
<body>

    <div class="header">
      <a href="/" class="logo_link">
        <img src="/img/saito_logo_black.png" class="logo" />
        <div class="logo_text">saito</div>
      </a>
    </div>

    <div class="main" style="padding-top:5px;min-width:750px;line-height:1.45em;">

<h2>What is Saito and Why is it Important?</h2>

<p></p>

Saito is a blockchain designed to process terabytes of data on a rolling basis. Our long-term goal is to handle over 100 terabytes of data each day, with the same levels of security and transaction irreversibility as bitcoin.

<p></p>

Why do we need a blockchain capable of processing this volume of data? While scaling payments is one idea, the real answer is that with such a large amount of blockspace available, Saito can let applications send information across its network along with their payments. On the software level, Saito does this by including a signed message field in every transaction that applications can use to store whatever data they wish. Letting applications read and write this data then turns our blockchain into a message-passing architecture that is both decentralized and censorship-resistent.

<p></p>

While there are various projects that attempt to use blockchain technology to enable non-payment usages, none has the flexibility or scalability of Saito, as they hard-code the additional data they need right into the blockchain. This decision -- made to minimize the amount of data required for storage on the blockchain -- is a product of the underlyinh design of their underlying blockchains, which require all nodes in the network to store all network data in perpetuity. Because Saito has a more sophisticated method of scaling, our network can afford to abstract away the entire application layer and let applications format their transactions however they would prefer. All applications which run on the network can define and upgrade their protocols on the fly: applications that require more data will simply need to pay a slightly higher fee than those transferring minimal amounts of data.

<p></p>

The end result is a new platform for blockchain applications, which can be distinguished from "smart contracts" by virtue of the fact that they run on the edge of the network and have no limitations on computational resources other than those imposed by the end-node itself. As unlike with smart contracts, under Saito it is possible to write extremely CPU-intensive and memory-intensive applications without bringing the servers in the peer-to-peer network to their knees. Not only does this flexibility allow the Saito blockchain to be used for applications that have historically been impossible to decentralize, but it allows new types of innovation in application development as applications can be rolled-out, tested and improved without the need for the entire blockchain ecosystem to upgrade.

<p></p>

What can we do with this new type of blockchain? Our <a href="/">online demos</a> showcase several possibilities: decentralized email and social media platforms. In the latter case, our ability to publish "posts" and "status updates" across the blockchain allows us to replace centralized messaging services like Facebook, Twitter and Reddit with truly peer-to-peer alternatives. At the extreme of current data capabilities, we could even take a stab at decentralizing our global email infrastructure: just attach the email message directly to your transaction.

<p></p>

More interesting possibilities emerge once we realize that we can use our big-data blockchain to build decentralized consensus. One example of an application like this is a decentralized DNS system: a censorship-resistent name-key registration platform. Other interesting possibilities are building decentralized advertising networks, and from there decentralized search engines. And then there are micropayments....

<p></p>

Essentially, what Saito offers is an entirely new type of blockchain designed to serve as a public infrastructure for public-key cryptography and message-passing. Additionally, Saito solves two fundamental problems in computer science: how to create secure encrypted connections on a distributed network, and how to avoid sybil attacks on nodes in a blockchain. Understanding how and why these work require a more detailed understanding of how Saito works, available in our technical explanation of <a href="/transactions.html">proof-of-transactions</a>.

<p></p>

<h2>Blockchain Scaling</h2>

<p></p>

The following table shows current scaling capabilities. The time estimates in the table below reflects the amount of time needed for the function indexAndStore() to add a new block to the blockchain. The data is based on current code as of January 2, 2018 and includes the time needed to verify inputs on all bundled transactions along with the indexing and storage of block data.

<p></p>

<table class="scaling_table">
  <tr>
    <th>Txs</th>
    <th>Tx Size</th>
    <th>Blk Size</th>
    <th>Callbacks</th>
    <th>Genesis Period</th>
    <th>Processing Time</th>
  </tr>
  <tr>
    <td>1</td>
    <td>1 MB</td>
    <td>1 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>1 second</td>
  </tr>
  <tr>
    <td>1</td>
    <td>25 MB</td>
    <td>25 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>2 seconds</td>
  </tr>
  <tr>
    <td>1000</td>
    <td>0.001 MB</td>
    <td>1 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>2 seconds</td>
  </tr>
  <tr>
    <td>1000</td>
    <td>0.025 MB</td>
    <td>25 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>6 seconds</td>
  </tr>
  <tr>
    <td>2000</td>
    <td>0.001 MB</td>
    <td>20 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>7 seconds</td>
  </tr>
  <tr>
    <td>1000</td>
    <td>0.05 MB</td>
    <td>50 MB</td>
    <td>100</td>
    <td>20160</td>
    <td>27 seconds</td>
  </tr>
</table>

<style>
table {
 min-width: 700px;
}
th {
 text-align: left;
}
td { 
 text-align: left;
 padding-right:10px;
}

</style>


<p></p>

These figures can be replicated by enabling our Spammer module, which can be used to stress-test the software. They were produced on a 2017 Macbook Air: professional servers with larger amounts of memory will perform better on-average.

<p></p>

David Lancashire
<br/>
<i>January 2018</i>

</div>

</body>
</html>
